package calculator

import calculator.autogenerated.CalculatorLexerAnalyzer
import calculator.autogenerated.CalculatorNode
import calculator.autogenerated.CalculatorParser
import io.github.rchowell.dotlin.DotRootGraph
import io.github.rchowell.dotlin.digraph
import org.junit.jupiter.api.Test
import java.io.File
import kotlin.test.assertEquals

class CalculatorParserTest {
    private var parser: CalculatorParser = CalculatorParser(CalculatorLexerAnalyzer("".byteInputStream()))
    private val outPath = File("src/test/kotlin/calculator/out").also { it.mkdirs() }

    @Test
    fun `simple test`() {
        setup("2 + 5 - 3")
        test("simple_test", 4.0)
    }

    @Test
    fun `priority test`() {
        setup("1 + 10 * 10 / 100")
        test("priority_test", 2.0)
    }

    @Test
    fun `brackets test`() {
        setup("(1 - 5) * (2 + 3)")
        test("brackets_test", -20.0)
    }

    @Test
    fun `unary minus test`() {
        setup("(-1 - -5) * 2")
        test("unary_minus_test", 8.0)
    }

    private fun test(name: String, expected: Double) {
        val tree = parser.parse()
        assertEquals(expected, tree.value)
        val graph = makeGraph(tree)
        saveImage(graph, name)
    }

    private fun makeGraph(tree: CalculatorNode): DotRootGraph {
        val graph = digraph {
            addSubgraph(tree)
        }
        println(graph.dot())
        return graph
    }

    private fun DotRootGraph.addSubgraph(tree: CalculatorNode) {
        tree.children.forEach {
            "\"${tree.id}\"" - "\"${it.id}\""
        }
        +subgraph {
            tree.children.forEach {
                +it.id.toString() + {
                    label = it.nodeName
                }
            }
            tree.children.forEach {
                addSubgraph(it)
            }
        }
    }

    private fun saveImage(graph: DotRootGraph, name: String) {
        val tempFile = createTempFile(name, graph.dot())
        val process = ProcessBuilder(
            "dot",
            "-Tpng",
            "-o",
            outPath.resolve("$name.png").absolutePath,
            tempFile.absolutePath
        ).start()
        process.waitFor()
        cleanTempFile(name)
    }

    private fun createTempFile(name: String, content: String): File {
        val file = File(outPath, name)
        file.writeText(content)
        return file
    }

    private fun cleanTempFile(name: String) {
        val file = File(outPath, name)
        file.delete()
    }

    private fun setup(input: String) {
        parser = CalculatorParser(CalculatorLexerAnalyzer(input.byteInputStream()))
    }
}