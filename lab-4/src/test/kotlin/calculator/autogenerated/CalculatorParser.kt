package calculator.autogenerated



class CalculatorParser(private val lexer: CalculatorLexerAnalyzer, ) {
	private var text: String = ""
	private var id = 0
	  get() = field++
	 val stack = ArrayDeque<Double>() 

	fun parse(): CalculatorNode {
		return start()
	}
	
	private fun fullGrammar(): CalculatorNode {
		val children = mutableListOf<CalculatorNode>()
		val result = CalculatorNode(id, "fullGrammar", children)
		when (lexer.token) {
			CalculatorToken.NUMBER -> {
				val var0 = term()
				children += var0
				result.value = var0.value
				val var1 = lowPriority()
				children += var1
				result.value = var1.value
				return result
			}
	
			CalculatorToken.LB -> {
				val var0 = term()
				children += var0
				result.value = var0.value
				val var1 = lowPriority()
				children += var1
				result.value = var1.value
				return result
			}
	
			CalculatorToken.MINUS -> {
				val var0 = term()
				children += var0
				result.value = var0.value
				val var1 = lowPriority()
				children += var1
				result.value = var1.value
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun highPriority(): CalculatorNode {
		val children = mutableListOf<CalculatorNode>()
		val result = CalculatorNode(id, "highPriority", children)
		when (lexer.token) {
			CalculatorToken.DIV -> {
				check(CalculatorToken.DIV, "DIV")
				text = lexer.tokenValue
				children += CalculatorNode(id, text)
				lexer.nextToken()
				val var0 = value()
				children += var0
				val second = stack.removeLast(); val first = stack.removeLast(); stack.addLast(first * second);
				val var1 = highPriority()
				children += var1
				result.value = var1.value;
				return result
			}
	
			CalculatorToken.MULT -> {
				check(CalculatorToken.MULT, "MULT")
				text = lexer.tokenValue
				children += CalculatorNode(id, text)
				lexer.nextToken()
				val var0 = value()
				children += var0
				val second = stack.removeLast(); val first = stack.removeLast(); if (second == 0.0) throw Exception("division by zero"); stack.addLast(first / second);
				val var1 = highPriority()
				children += var1
				result.value = var1.value;
				return result
			}
	
			CalculatorToken.RB -> {
				result.value = stack.last();
				children += CalculatorNode(id, "EPS")
				return result
			}
	
			CalculatorToken.EOF -> {
				result.value = stack.last();
				children += CalculatorNode(id, "EOF")
				return result
			}
	
			CalculatorToken.PLUS -> {
				result.value = stack.last();
				children += CalculatorNode(id, "EPS")
				return result
			}
	
			CalculatorToken.MINUS -> {
				result.value = stack.last();
				children += CalculatorNode(id, "EPS")
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun start(): CalculatorNode {
		val children = mutableListOf<CalculatorNode>()
		val result = CalculatorNode(id, "start", children)
		when (lexer.token) {
			CalculatorToken.NUMBER -> {
				val var0 = fullGrammar()
				children += var0
				result.value = var0.value
				return result
			}
	
			CalculatorToken.LB -> {
				val var0 = fullGrammar()
				children += var0
				result.value = var0.value
				return result
			}
	
			CalculatorToken.MINUS -> {
				val var0 = fullGrammar()
				children += var0
				result.value = var0.value
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun term(): CalculatorNode {
		val children = mutableListOf<CalculatorNode>()
		val result = CalculatorNode(id, "term", children)
		when (lexer.token) {
			CalculatorToken.NUMBER -> {
				val var0 = value()
				children += var0
				val var1 = highPriority()
				children += var1
				result.value = var1.value;
				return result
			}
	
			CalculatorToken.LB -> {
				val var0 = value()
				children += var0
				val var1 = highPriority()
				children += var1
				result.value = var1.value;
				return result
			}
	
			CalculatorToken.MINUS -> {
				val var0 = value()
				children += var0
				val var1 = highPriority()
				children += var1
				result.value = var1.value;
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun lowPriority(): CalculatorNode {
		val children = mutableListOf<CalculatorNode>()
		val result = CalculatorNode(id, "lowPriority", children)
		when (lexer.token) {
			CalculatorToken.RB -> {
				result.value = stack.last();
				children += CalculatorNode(id, "EPS")
				return result
			}
	
			CalculatorToken.EOF -> {
				result.value = stack.last();
				children += CalculatorNode(id, "EOF")
				return result
			}
	
			CalculatorToken.PLUS -> {
				check(CalculatorToken.PLUS, "PLUS")
				text = lexer.tokenValue
				children += CalculatorNode(id, text)
				lexer.nextToken()
				val var0 = term()
				children += var0
				val second = stack.removeLast(); val first = stack.removeLast(); stack.addLast(first - second);
				val var1 = lowPriority()
				children += var1
				result.value = var1.value;
				return result
			}
	
			CalculatorToken.MINUS -> {
				check(CalculatorToken.MINUS, "MINUS")
				text = lexer.tokenValue
				children += CalculatorNode(id, text)
				lexer.nextToken()
				val var0 = term()
				children += var0
				val second = stack.removeLast(); val first = stack.removeLast(); stack.addLast(first + second);
				val var1 = lowPriority()
				children += var1
				result.value = var1.value;
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun value(): CalculatorNode {
		val children = mutableListOf<CalculatorNode>()
		val result = CalculatorNode(id, "value", children)
		when (lexer.token) {
			CalculatorToken.NUMBER -> {
				check(CalculatorToken.NUMBER, "NUMBER")
				text = lexer.tokenValue
				children += CalculatorNode(id, text)
				lexer.nextToken()
				result.value = text.toDouble(); stack.addLast(text.toDouble());
				return result
			}
	
			CalculatorToken.LB -> {
				check(CalculatorToken.LB, "LB")
				text = lexer.tokenValue
				children += CalculatorNode(id, text)
				lexer.nextToken()
				val var0 = start()
				children += var0
				check(CalculatorToken.RB, "RB")
				text = lexer.tokenValue
				children += CalculatorNode(id, text)
				lexer.nextToken()
				result.value = var0.value;
				return result
			}
	
			CalculatorToken.MINUS -> {
				check(CalculatorToken.MINUS, "MINUS")
				text = lexer.tokenValue
				children += CalculatorNode(id, text)
				lexer.nextToken()
				check(CalculatorToken.NUMBER, "NUMBER")
				text = lexer.tokenValue
				children += CalculatorNode(id, text)
				lexer.nextToken()
				result.value = -text.toDouble(); stack.addLast(-text.toDouble());
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun check(token: CalculatorToken, rule: String): Unit {
		if (lexer.token != token) {
			throw IllegalStateException("Expected $rule, but found ${lexer.token}")
		}
	
	}
}