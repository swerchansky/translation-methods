package lab2.autogenerated



class Lab2Parser(private val lexer: Lab2LexerAnalyzer, ) {
	private var text: String = ""
	private var id = 0
	  get() = field++

	fun parse(): Lab2Node {
		return start()
	}
	
	private fun varType(): Lab2Node {
		val children = mutableListOf<Lab2Node>()
		val result = Lab2Node(id, "varType", children)
		when (lexer.token) {
			Lab2Token.ARRAY -> {
				check(Lab2Token.ARRAY, "ARRAY")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				check(Lab2Token.LB, "LB")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				val var0 = type()
				children += var0
				check(Lab2Token.RB, "RB")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.TUPLE -> {
				check(Lab2Token.TUPLE, "TUPLE")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				check(Lab2Token.LB, "LB")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				val var0 = multipleType()
				children += var0
				check(Lab2Token.RB, "RB")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun multipleType(): Lab2Node {
		val children = mutableListOf<Lab2Node>()
		val result = Lab2Node(id, "multipleType", children)
		when (lexer.token) {
			Lab2Token.FLOAT -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.ARRAY -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.BOOL -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.BYTE -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.STRING -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.CHAR -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.DOUBLE -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.ANY -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.INT -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.SHORT -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			Lab2Token.LONG -> {
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun start(): Lab2Node {
		val children = mutableListOf<Lab2Node>()
		val result = Lab2Node(id, "start", children)
		when (lexer.token) {
			Lab2Token.VAR -> {
				check(Lab2Token.VAR, "VAR")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				check(Lab2Token.VARIABLE, "VARIABLE")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				check(Lab2Token.SC, "SC")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				val var0 = varType()
				children += var0
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun nextType(): Lab2Node {
		val children = mutableListOf<Lab2Node>()
		val result = Lab2Node(id, "nextType", children)
		when (lexer.token) {
			Lab2Token.RB -> {
				children += Lab2Node(id, "EPS")
				return result
			}
	
			Lab2Token.CM -> {
				check(Lab2Token.CM, "CM")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				val var0 = type()
				children += var0
				val var1 = nextType()
				children += var1
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun type(): Lab2Node {
		val children = mutableListOf<Lab2Node>()
		val result = Lab2Node(id, "type", children)
		when (lexer.token) {
			Lab2Token.FLOAT -> {
				check(Lab2Token.FLOAT, "FLOAT")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.ARRAY -> {
				check(Lab2Token.ARRAY, "ARRAY")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.BOOL -> {
				check(Lab2Token.BOOL, "BOOL")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.BYTE -> {
				check(Lab2Token.BYTE, "BYTE")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.STRING -> {
				check(Lab2Token.STRING, "STRING")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.CHAR -> {
				check(Lab2Token.CHAR, "CHAR")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.DOUBLE -> {
				check(Lab2Token.DOUBLE, "DOUBLE")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.ANY -> {
				check(Lab2Token.ANY, "ANY")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.INT -> {
				check(Lab2Token.INT, "INT")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.SHORT -> {
				check(Lab2Token.SHORT, "SHORT")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			Lab2Token.LONG -> {
				check(Lab2Token.LONG, "LONG")
				text = lexer.tokenValue
				children += Lab2Node(id, text)
				lexer.nextToken()
				return result
			}
	
			else -> {
				throw IllegalStateException("Unexpected token: ${lexer.token}")
			}
	
		}
	
	}
	
	private fun check(token: Lab2Token, rule: String): Unit {
		if (lexer.token != token) {
			throw IllegalStateException("Expected $rule, but found ${lexer.token}")
		}
	
	}
}