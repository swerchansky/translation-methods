package lab3

import lab3.autogenerated.Lab3Node
import kotlin.math.pow

class Lab3NodeVisitor {
    var output = ""
        private set
    private val variables = HashMap<String, Double>()
    private val stack = ArrayDeque<Double>()

    fun visit(tree: Lab3Node): Double {
        tree.children.forEach {
            visitFullGrammar(it)
        }
        return 0.0
    }

    private fun visitFullGrammar(tree: Lab3Node): Double {
        val variable = tree.children[0].nodeName
        val term1 = tree.children[2]
        val lowPriority = tree.children[3]
        visitTerm1(term1)
        val value = visitLowPriority(lowPriority)
        variables[variable] = value
        output += "$variable = $value"
        output += System.lineSeparator()
        val fullGrammarEps = tree.children.last()
        if (fullGrammarEps.children.isNotEmpty()) {
            visitFullGrammarEps(fullGrammarEps)
        }
        return value
    }

    private fun visitFullGrammarEps(tree: Lab3Node): Double {
        val children = tree.children.first()
        if (children.nodeName == "fullGrammar") {
            visitFullGrammar(children)
        }
        return 0.0
    }

    private fun visitTerm1(tree: Lab3Node): Double {
        val term2 = tree.children[0]
        visitTerm2(term2)
        return visitHighPriority(tree.children[1])
    }

    private fun visitTerm2(tree: Lab3Node): Double {
        val value = tree.children[0]
        visitValue(value)
        return visitPower(tree.children[1])
    }

    private fun visitPower(tree: Lab3Node): Double {
        if (tree.children.size == 1) return stack.last()

        visitValue(tree.children[1])
        visitPower(tree.children[2])
        val right = stack.removeLast()
        val left = stack.removeLast()
        stack.addLast(left.pow(right))
        return stack.last()
    }

    private fun visitHighPriority(tree: Lab3Node): Double {
        if (tree.children.size == 1) return stack.last()

        visitValue(tree.children[1])
        when (tree.children[0].nodeName) {
            "*" -> {
                val right = stack.removeLast()
                val left = stack.removeLast()
                stack.addLast(left * right)
            }

            "/" -> {
                val right = stack.removeLast()
                val left = stack.removeLast()
                stack.addLast(left / right)
            }
        }
        return visitHighPriority(tree.children[2])
    }

    private fun visitLowPriority(tree: Lab3Node): Double {
        if (tree.children.size == 1) return stack.last()

        val term = tree.children[1]
        val lowPriority = tree.children[2]
        visitTerm1(term)

        when (tree.children[0].nodeName) {
            "+" -> {
                val right = stack.removeLast()
                val left = stack.removeLast()
                stack.addLast(left + right)
            }

            "-" -> {
                val right = stack.removeLast()
                val left = stack.removeLast()
                stack.addLast(left - right)
            }
        }

        return visitLowPriority(lowPriority)
    }

    private fun visitValue(tree: Lab3Node): Double {
        if (tree.children.size == 4) {
            val term1 = tree.children[1]
            val lowPriority = tree.children[2]
            visitTerm1(term1)
            val value = visitLowPriority(lowPriority)
            return value
        }
        try {
            val value = tree.children[0].nodeName.toDouble()
            stack.addLast(value)
            return value
        } catch (e: Exception) {
            val value = variables[tree.children[0].nodeName] ?: 0.0
            stack.addLast(value)
            return value
        }
    }
}